<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FormFit AI - Voice Coach</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="./style/main.css">
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==================== VOICE COACH ====================
        class VoiceCoach {
            constructor() {
                this.synth = window.speechSynthesis;
                this.enabled = true; this.lastSpoke = 0; this.minGap = 6000;
                this.speaking = false; this.message = ""; this.onChange = null;
                const setVoice = () => { this.voice = this.synth.getVoices().find(v => v.lang.includes('en')) || this.synth.getVoices()[0]; };
                if (this.synth.getVoices().length) setVoice(); else this.synth.onvoiceschanged = setVoice;
            }
            speak(msg, force = false) {
                if (!this.enabled || !msg) return;
                if (!force && Date.now() - this.lastSpoke < this.minGap) return;
                this.synth.cancel();
                const u = new SpeechSynthesisUtterance(msg); u.voice = this.voice; u.rate = 1.1;
                u.onstart = () => { this.speaking = true; this.message = msg; this.onChange?.(true, msg); };
                u.onend = () => { this.speaking = false; this.lastSpoke = Date.now(); this.onChange?.(false, ""); };
                this.synth.speak(u);
            }
            getFeedback(acc, fb, isMoving, isInPosition) {
                // Not moving - prompt to start
                if (!isMoving) {
                    return "Start moving! Begin the exercise.";
                }
                // Not in proper position
                if (!isInPosition) {
                    return "Get into position first.";
                }
                // Good form while moving
                if (acc >= 95) return ["Perfect!", "Great form!", "Excellent!"][Math.floor(Math.random() * 3)];
                if (acc >= 65) return "Good! Keep going!";
                // Needs improvement
                if (fb?.length) {
                    const f = fb[0];
                    if (f.includes('elbow') && f.includes('extend')) return "Extend your arms more!";
                    if (f.includes('elbow') && f.includes('bend')) return "Bend your elbows more!";
                    if (f.includes('knee') && f.includes('bend')) return "Go lower!";
                    if (f.includes('knee') && f.includes('extend')) return "Stand up fully!";
                    return "Check your form!";
                }
                return "Keep going!";
            }
            announceRep(n) { 
                if (!this.enabled) return; 
                if (n === 1) this.speak("One!", true);
                else if (n === 5) this.speak("Five! Great job!", true);
                else if (n === 10) this.speak("Ten! You're on fire!", true);
                else if (n % 5 === 0) this.speak(`${n}!`, true);
                else this.speak(`${n}`, true);
            }
            start(name) { this.speak(`Starting ${name}. Get into position and begin!`, true); }
            end(name, reps) { this.speak(`Done! ${reps} reps of ${name}. Great workout!`, true); }
            stop() { this.synth.cancel(); this.speaking = false; }
            setEnabled(v) { this.enabled = v; if (!v) this.stop(); }
        }
        const voiceCoach = new VoiceCoach();

        // ==================== POSE UTILS ====================
        const calcAngle = (a, b, c) => {
            const v1x = a.x - b.x, v1y = a.y - b.y, v2x = c.x - b.x, v2y = c.y - b.y;
            return Math.acos(Math.max(-1, Math.min(1, (v1x * v2x + v1y * v2y) / (Math.sqrt(v1x * v1x + v1y * v1y) * Math.sqrt(v2x * v2x + v2y * v2y) + 0.001)))) * 57.2958;
        };

        const getAngles = (lm) => lm?.length >= 29 ? {
            left_elbow: calcAngle(lm[11], lm[13], lm[15]), 
            right_elbow: calcAngle(lm[12], lm[14], lm[16]),
            left_knee: calcAngle(lm[23], lm[25], lm[27]), 
            right_knee: calcAngle(lm[24], lm[26], lm[28]),
            left_arm_raise: calcAngle(lm[23], lm[11], lm[13]), 
            right_arm_raise: calcAngle(lm[24], lm[12], lm[14])
        } : null;

        // Check if angle is in phase range
        const isInPhase = (angles, phaseAngles) => {
            let matches = 0, total = 0;
            for (const [name, [min, max]] of Object.entries(phaseAngles)) {
                if (angles[name] !== undefined) {
                    total++;
                    if (angles[name] >= min && angles[name] <= max) matches++;
                }
            }
            return total > 0 && (matches / total) >= 0.7; // 70% of angles must match
        };

        const evaluateForm = (angles, ex, currentPhase) => {
            const phases = ex.phases;
            const phaseNames = Object.keys(phases);
            let bestPh = 'TRANSITION', bestScore = 0;
            const fb = [];

            for (const [ph, phAngles] of Object.entries(phases)) {
                let score = 0, total = 0;
                for (const [name, [min, max]] of Object.entries(phAngles)) {
                    if (angles[name] !== undefined) {
                        total++; 
                        const v = angles[name];
                        if (v >= min && v <= max) {
                            score += 100;
                        } else { 
                            const diff = v < min ? min - v : v - max; 
                            score += Math.max(0, 100 - diff * 2.5); 
                            if (diff > 20) {
                                fb.push(`${name.replace(/_/g, ' ')}: ${v < min ? 'extend' : 'bend'} more`);
                            }
                        }
                    }
                }
                if (total > 0 && score / total > bestScore) { 
                    bestScore = score / total; 
                    bestPh = ph; 
                }
            }
            
            return { accuracy: bestScore, phase: bestPh, feedback: [...new Set(fb)].slice(0, 2) };
        };

        const CONNS = [[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[25,27],[24,26],[26,28]];
        
        const drawSkeleton = (ctx, lm, w, h, color) => {
            ctx.strokeStyle = color; ctx.lineWidth = 3;
            CONNS.forEach(([a, b]) => { 
                ctx.beginPath(); 
                ctx.moveTo(lm[a].x * w, lm[a].y * h); 
                ctx.lineTo(lm[b].x * w, lm[b].y * h); 
                ctx.stroke(); 
            });
            ctx.fillStyle = color; 
            for (let i = 11; i < 29; i++) { 
                ctx.beginPath(); 
                ctx.arc(lm[i].x * w, lm[i].y * h, 5, 0, 6.28); 
                ctx.fill(); 
            }
        };

        // ==================== EXERCISES ====================
        const EXERCISES = [
            { 
                id: "shoulder_press", 
                name: "Shoulder Press", 
                category: "Shoulders", 
                gif: "https://media1.tenor.com/m/vFJSvh8AvhAAAAAC/a1.gif", 
                muscles: ["Deltoids", "Triceps"], 
                description: "Press weights overhead", 
                phases: { 
                    DOWN: { left_elbow: [60, 110], right_elbow: [60, 110] }, 
                    UP: { left_elbow: [155, 180], right_elbow: [155, 180] } 
                }, 
                // Key angle to track for movement detection
                trackAngle: 'left_elbow',
                movementThreshold: 25, // Minimum angle change to count as movement
                tips: ["Feet shoulder-width", "Weights at shoulders", "Press straight up", "Lower with control"] 
            },
            { 
                id: "squat", 
                name: "Squat", 
                category: "Legs", 
                gif: "https://media1.tenor.com/m/Pfj8vy41k-0AAAAC/gym.gif", 
                muscles: ["Quads", "Glutes"], 
                description: "Lower body strength", 
                phases: { 
                    STANDING: { left_knee: [160, 180], right_knee: [160, 180] }, 
                    BOTTOM: { left_knee: [70, 110], right_knee: [70, 110] } 
                }, 
                trackAngle: 'left_knee',
                movementThreshold: 30,
                tips: ["Feet shoulder-width", "Chest up", "Thighs parallel", "Drive through heels"] 
            },
            { 
                id: "pushup", 
                name: "Push Up", 
                category: "Chest", 
                gif: "https://media1.tenor.com/m/EEJO0ylQ8tAAAAAC/flexiones-basicas.gif", 
                muscles: ["Chest", "Triceps"], 
                description: "Upper body classic", 
                phases: { 
                    UP: { left_elbow: [160, 180], right_elbow: [160, 180] }, 
                    DOWN: { left_elbow: [70, 110], right_elbow: [70, 110] } 
                }, 
                trackAngle: 'left_elbow',
                movementThreshold: 30,
                tips: ["Hands wide", "Body straight", "Chest to ground", "Push up fully"] 
            },
            { 
                id: "lunge", 
                name: "Lunge", 
                category: "Legs", 
                gif: "https://media1.tenor.com/m/sZ7VwZ6jrbcAAAAC/gym.gif", 
                muscles: ["Quads", "Glutes"], 
                description: "Unilateral leg strength", 
                phases: { 
                    STANDING: { left_knee: [150, 180], right_knee: [150, 180] }, 
                    DOWN: { left_knee: [80, 120], right_knee: [80, 120] } 
                }, 
                trackAngle: 'left_knee',
                movementThreshold: 30,
                tips: ["Step forward", "Both knees 90¬∞", "Front knee over ankle", "Push back"] 
            },
            { 
                id: "lateral_raise", 
                name: "Lateral Raise", 
                category: "Shoulders", 
                gif: "https://media1.tenor.com/m/-OavRqpxSaEAAAAC/eleva%C3%A7%C3%A3o-lateral.gif", 
                muscles: ["Side Delts"], 
                description: "Wider shoulders", 
                phases: { 
                    DOWN: { left_arm_raise: [0, 40], right_arm_raise: [0, 40] }, 
                    UP: { left_arm_raise: [70, 110], right_arm_raise: [70, 110] } 
                },
                trackAngle: 'left_arm_raise',
                movementThreshold: 30,
                tips: ["Dumbbells at sides", "Slight elbow bend", "Raise to shoulder height", "Control"] 
            }
        ];
        const CATEGORIES = ['All', 'Shoulders', 'Chest', 'Arms', 'Legs'];

        // ==================== COMPONENTS ====================
        const Header = ({ totalReps }) => (
            <header className="header">
                <div className="logo"><img src="./FINAL FormFit logo.png" alt="FormFit" className="logo-img"/> Form<span>Fit</span> AI</div>
                <div className="header-right">
                    <div className="stat">
                        <div className="stat-value">{totalReps}</div>
                        <div className="stat-label">Total Reps</div>
                    </div>
                </div>
            </header>
        );

        const VoiceBanner = ({ voiceOn, setVoiceOn, speaking }) => (
            <div className="voice-banner">
                <div className={`voice-avatar ${speaking ? 'speaking' : ''}`}>ü§ñ</div>
                <div className="voice-info">
                    <div className="voice-title">AI Voice Coach</div>
                    <div className="voice-status">{voiceOn ? "Ready to guide" : "Voice off"}</div>
                </div>
                <button className={`btn ${voiceOn ? 'btn-purple' : 'btn-secondary'}`} onClick={() => setVoiceOn(!voiceOn)}>
                    {voiceOn ? 'üîä On' : 'üîá Off'}
                </button>
            </div>
        );

        const CategoryTabs = ({ categories, active, onChange }) => (
            <div className="tabs">
                {categories.map(c => (
                    <button key={c} className={`tab ${active === c ? 'active' : ''}`} onClick={() => onChange(c)}>{c}</button>
                ))}
            </div>
        );

        const ExerciseCard = ({ exercise, onClick }) => (
            <div className="card" onClick={onClick}>
                <div className="card-img"><img src={exercise.gif} alt={exercise.name} loading="lazy" /></div>
                <div className="card-body">
                    <div className="card-category">{exercise.category}</div>
                    <div className="card-title">{exercise.name}</div>
                    <div className="card-desc">{exercise.description}</div>
                    <div className="card-muscles">{exercise.muscles.map(m => <span key={m} className="muscle-tag">{m}</span>)}</div>
                </div>
            </div>
        );

        const ExerciseGrid = ({ exercises, onSelect }) => (
            <div className="grid">
                {exercises.map(e => <ExerciseCard key={e.id} exercise={e} onClick={() => onSelect(e)} />)}
            </div>
        );

        const VideoOverlay = ({ fps, accuracy, phase, reps, speaking, coachMsg, isMoving, repState }) => (
            <div className="overlay">
                <div className="fps-counter">{fps} FPS</div>
                <div className="stat-box accuracy-box">
                    <div className="label">{isMoving ? 'Accuracy' : 'Status'}</div>
                    <div className={`value ${isMoving ? (accuracy > 70 ? 'good' : accuracy > 40 ? 'ok' : 'bad') : 'bad'}`}>
                        {isMoving ? `${accuracy}%` : 'Idle'}
                    </div>
                </div>
                <div className="stat-box phase-box">
                    <div className="label">Phase</div>
                    <div className={`value ${!isMoving ? 'idle' : ''}`}>{isMoving ? phase : 'WAITING'}</div>
                </div>
                <div className="stat-box rep-box">
                    <div className="label">Reps</div>
                    <div className="value">{reps}</div>
                </div>
                <div className={`coach-box ${speaking ? 'speaking' : ''}`}>
                    <div className="coach-avatar-sm">ü§ñ</div>
                    <div className="coach-msg">{coachMsg || (isMoving ? "Keep going!" : "Start the exercise!")}</div>
                </div>
            </div>
        );

        const ExercisePreview = ({ exercise }) => (
            <div className="panel-card">
                <img src={exercise.gif} alt={exercise.name} className="preview-img" />
                <div className="preview-name">{exercise.name}</div>
                <div className="preview-cat">{exercise.category}</div>
            </div>
        );

        const VoiceSettings = ({ voiceOn, setVoiceOn }) => (
            <div className="panel-card">
                <div className="panel-title">üé§ Voice Coach</div>
                <div className="toggle-row">
                    <span>Voice Feedback</span>
                    <div className={`toggle ${voiceOn ? 'on' : ''}`} onClick={() => setVoiceOn(!voiceOn)} />
                </div>
            </div>
        );

        const FeedbackPanel = ({ feedback, isMoving }) => (
            <div className="panel-card">
                <div className="panel-title">Feedback</div>
                {!isMoving ? (
                    <div className="feedback-item warning">‚è≥ Start exercising to get feedback</div>
                ) : feedback.length === 0 ? (
                    <div className="feedback-item good">‚úì Great form!</div>
                ) : (
                    feedback.map((f, i) => <div key={i} className="feedback-item bad">! {f}</div>)
                )}
            </div>
        );

        const InstructionsPanel = ({ tips }) => (
            <div className="panel-card">
                <div className="panel-title">Tips</div>
                {tips.map((t, i) => (
                    <div key={i} className="instruction">
                        <div className="instruction-num">{i + 1}</div>
                        <div className="instruction-text">{t}</div>
                    </div>
                ))}
            </div>
        );

        const Loading = ({ message }) => (
            <div className="loading">
                <div className="loading-icon"></div>
                <div>{message}</div>
            </div>
        );

        // ==================== VIEWS ====================
        const BrowseView = ({ category, setCategory, onSelect, voiceOn, setVoiceOn, speaking }) => {
            const exercises = category === 'All' ? EXERCISES : EXERCISES.filter(e => e.category === category);
            return (
                <>
                    <VoiceBanner voiceOn={voiceOn} setVoiceOn={setVoiceOn} speaking={speaking} />
                    <div className="page-title">
                        <h1>Choose Exercise</h1>
                        <p>AI form analysis with voice coaching</p>
                    </div>
                    <CategoryTabs categories={CATEGORIES} active={category} onChange={setCategory} />
                    <ExerciseGrid exercises={exercises} onSelect={onSelect} />
                </>
            );
        };

        const AnalyzeView = ({ exercise, onBack, onRep, voiceOn, setVoiceOn, speaking, coachMsg }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const poseRef = useRef(null);
            
            // Movement tracking
            const angleHistory = useRef([]);
            const lastPhaseRef = useRef(null);
            const repStateRef = useRef('IDLE'); // IDLE -> PHASE1 -> PHASE2 -> counted
            const lastFB = useRef(0);
            const frameCount = useRef(0);
            const lastFpsTime = useRef(Date.now());
            const processing = useRef(false);
            
            const [ready, setReady] = useState(false);
            const [accuracy, setAccuracy] = useState(0);
            const [phase, setPhase] = useState('READY');
            const [reps, setReps] = useState(0);
            const [feedback, setFeedback] = useState([]);
            const [fps, setFps] = useState(0);
            const [isMoving, setIsMoving] = useState(false);
            const [repState, setRepState] = useState('IDLE');

            const onResults = useCallback((results) => {
                const canvas = canvasRef.current;
                const ctx = canvas?.getContext('2d');
                if (!ctx) return;

                // FPS
                frameCount.current++;
                const now = Date.now();
                if (now - lastFpsTime.current >= 1000) { 
                    setFps(frameCount.current); 
                    frameCount.current = 0; 
                    lastFpsTime.current = now; 
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (results.poseLandmarks) {
                    const lm = results.poseLandmarks;
                    const angles = getAngles(lm);
                    
                    if (angles) {
                        // Track angle history for movement detection
                        const trackAngle = exercise.trackAngle || 'left_elbow';
                        angleHistory.current.push(angles[trackAngle]);
                        if (angleHistory.current.length > 15) angleHistory.current.shift();
                        
                        // Detect movement - check if angle changed significantly
                        let moving = false;
                        if (angleHistory.current.length >= 10) {
                            const recent = angleHistory.current.slice(-10);
                            const min = Math.min(...recent);
                            const max = Math.max(...recent);
                            const range = max - min;
                            moving = range > (exercise.movementThreshold || 25);
                        }
                        setIsMoving(moving);

                        // Evaluate form
                        const { accuracy: acc, phase: ph, feedback: fb } = evaluateForm(angles, exercise, phase);
                        
                        // Only show accuracy when moving
                        if (moving) {
                            setAccuracy(Math.round(acc));
                            setFeedback(fb);
                        } else {
                            setAccuracy(0);
                            setFeedback([]);
                        }
                        setPhase(ph);

                        // REP COUNTING STATE MACHINE
                        const phaseNames = Object.keys(exercise.phases);
                        const phase1 = phaseNames[0]; // e.g., DOWN or STANDING
                        const phase2 = phaseNames[1]; // e.g., UP or BOTTOM

                        // Check if truly in phase (not just close)
                        const inPhase1 = isInPhase(angles, exercise.phases[phase1]);
                        const inPhase2 = isInPhase(angles, exercise.phases[phase2]);

                        // State machine for rep counting
                        if (moving) {
                            const currentState = repStateRef.current;
                            
                            if (currentState === 'IDLE' && inPhase1) {
                                repStateRef.current = 'PHASE1';
                                setRepState('PHASE1');
                            } 
                            else if (currentState === 'PHASE1' && inPhase2) {
                                repStateRef.current = 'PHASE2';
                                setRepState('PHASE2');
                            }
                            else if (currentState === 'PHASE2' && inPhase1) {
                                // Completed a full rep!
                                setReps(r => {
                                    const newReps = r + 1;
                                    voiceCoach.announceRep(newReps);
                                    onRep();
                                    return newReps;
                                });
                                repStateRef.current = 'PHASE1'; // Ready for next rep
                                setRepState('PHASE1');
                            }
                        }

                        // Voice feedback - only when moving
                        if (now - lastFB.current > 4000) {
                            const msg = voiceCoach.getFeedback(acc, fb, moving, repStateRef.current !== 'IDLE');
                            voiceCoach.speak(msg);
                            lastFB.current = now;
                        }

                        // Draw skeleton
                        const color = !moving ? '#888888' : (acc > 70 ? '#00ff87' : acc > 40 ? '#00d4ff' : '#ff3860');
                        drawSkeleton(ctx, lm, canvas.width, canvas.height, color);
                    }
                }
            }, [exercise, onRep, phase]);

            useEffect(() => {
                const init = async () => {
                    const pose = new Pose({ 
                        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}` 
                    });
                    pose.setOptions({ 
                        modelComplexity: 0, 
                        smoothLandmarks: true, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    pose.onResults(onResults);
                    poseRef.current = pose;

                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { width: 640, height: 480, facingMode: 'user' } 
                        });
                        videoRef.current.srcObject = stream;
                        await videoRef.current.play();
                        canvasRef.current.width = videoRef.current.videoWidth;
                        canvasRef.current.height = videoRef.current.videoHeight;
                        setReady(true);
                        voiceCoach.start(exercise.name);

                        let skip = 0;
                        const process = async () => {
                            if (!poseRef.current) return;
                            skip++; 
                            if (skip % 2 === 0 && !processing.current) { 
                                processing.current = true; 
                                await poseRef.current.send({ image: videoRef.current }); 
                                processing.current = false; 
                            }
                            requestAnimationFrame(process);
                        };
                        process();
                    } catch (e) { 
                        alert("Camera access denied"); 
                    }
                };
                init();

                return () => { 
                    videoRef.current?.srcObject?.getTracks().forEach(t => t.stop()); 
                    poseRef.current?.close(); 
                    voiceCoach.stop(); 
                };
            }, []);

            const stop = () => { 
                voiceCoach.end(exercise.name, reps); 
                onBack(); 
            };

            return (
                <>
                    <div className="back-btn" onClick={stop}>‚Üê Back</div>
                    <div className="analysis">
                        <div className="video-box">
                            <video ref={videoRef} playsInline style={{ transform: 'scaleX(-1)' }} />
                            <canvas ref={canvasRef} style={{ transform: 'scaleX(-1)' }} />
                            {ready ? (
                                <VideoOverlay 
                                    fps={fps} 
                                    accuracy={accuracy} 
                                    phase={phase} 
                                    reps={reps} 
                                    speaking={speaking} 
                                    coachMsg={coachMsg}
                                    isMoving={isMoving}
                                    repState={repState}
                                />
                            ) : (
                                <Loading message="Loading camera..." />
                            )}
                        </div>
                        <div className="panel">
                            <ExercisePreview exercise={exercise} />
                            <VoiceSettings voiceOn={voiceOn} setVoiceOn={setVoiceOn} />
                            <FeedbackPanel feedback={feedback} isMoving={isMoving} />
                            <InstructionsPanel tips={exercise.tips} />
                            <button className="btn btn-danger btn-full" onClick={stop}>End Workout</button>
                        </div>
                    </div>
                </>
            );
        };

        // ==================== APP ====================
        const App = () => {
            const [view, setView] = useState('browse');
            const [exercise, setExercise] = useState(null);
            const [category, setCategory] = useState('All');
            const [totalReps, setTotalReps] = useState(0);
            const [voiceOn, setVoiceOn] = useState(true);
            const [speaking, setSpeaking] = useState(false);
            const [coachMsg, setCoachMsg] = useState("");

            useEffect(() => { 
                voiceCoach.onChange = (s, m) => { setSpeaking(s); setCoachMsg(m); }; 
            }, []);
            
            useEffect(() => { 
                voiceCoach.setEnabled(voiceOn); 
            }, [voiceOn]);

            return (
                <div className="app">
                    <Header totalReps={totalReps} />
                    <main className="main">
                        {view === 'browse' ? (
                            <BrowseView 
                                category={category} 
                                setCategory={setCategory} 
                                onSelect={e => { setExercise(e); setView('analyze'); }} 
                                voiceOn={voiceOn} 
                                setVoiceOn={setVoiceOn} 
                                speaking={speaking} 
                            />
                        ) : (
                            <AnalyzeView 
                                exercise={exercise} 
                                onBack={() => setView('browse')} 
                                onRep={() => setTotalReps(t => t + 1)} 
                                voiceOn={voiceOn} 
                                setVoiceOn={setVoiceOn} 
                                speaking={speaking} 
                                coachMsg={coachMsg} 
                            />
                        )}
                    </main>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
        
    </script>
    <p>hrloo</p>
</body>
</html>